-----------------------------------------------------------------------------------------前言---------------------------------------------------------------------------------------------

git命令：git 终端的命令除了以git开头的命令，其他的命令和部分Linux命令是一样的，比如清屏的命令为 clear 。   20201025

分支：克隆远程库到本地或者本地git init创建本地库后，出现的 .git 文件内就是该项目的master等若干个分支的所在地，包括各个分支自己的暂存区和本地库。但git log系列命令展示出
          的版本栈信息，是所有分支一起的，且不能通过展示出的版本栈的树状图区分各个分支。


工作区(worktree)   ————>   暂存区(index file)   ————>   本地库      
     工作区(worktree)：呈现的是当前所处本地库的一个版本所对应的内容，并实时体现在此内容上我临时所作的变动后的实时状态。
     暂存区(index file)：存放的是git add跟踪进来的内容，是一个版本栈；add跟踪进来的就一直在暂存区中，不会因后续commit而被挪走，commit相当于是复刻一份到本地库。
     本地库：【git log 系列命令可以查看】中的各个版本本质上保存的是工作区内各次更改后git add并git commit的所有文件和文件内容的状态。


版本：哈希函数（如MD5、SHA系列）的特点是，传进一个值A，会输出一个唯一与A对应的a，一旦A被改动，改动后的A再次输入哈希函数后，输出的值必定不再是a，若还是a则
         是哈希冲突；但这个过程不可逆，即不能由a通过哈希函数逆运算得到A。利用该特性，可检测一个东西是否被改动过。git的版本号就使用了这个原理。每次commit提交的版
         本有哈希值作为唯一标识符。

git命令帮助：git help reset        查询 git reset 这个命令的使用说明   具体的就在如下路径文件夹中   
			G:/golang_go0bian1cheng2_20200930/Git_new_20201024/Git/mingw64/share/doc/git-doc/


----------------------------------------------------------------------------------工作区(worktree)---------------------------------------------------------------------------------------

0、工作区就是以前没有版本控制的时代，我们看到的可以随时被改变的内容


--------------------------------------------------------------------------------------暂存区-----------------------------------------------------------------------------------------------
						【又叫index，又叫缓存区--cashed，又叫--staged】
1、
|     git status        		显示当前目录下的暂存区(又叫index file)的情况，颜色为红色的文件是处于工作区的被改动或被删除过的文件或文件夹，等待git add跟踪进暂存区，
|	      		绿色的文件是已经在暂存区的被修改或被删除的文件或文件夹，等待git commit添加进本地库
|
|1.1、放弃工作区的修改或删除【慎用】
|     git checkout .		抛弃工作区中的内容修改或文件删除操作(但对于新增文件的情形，不恢复到未新增文件的状态！)，让工作区内容回到和本地库的当前状态一样的状态。
|     git restore xxx.txt		如果想抛弃在工作区对 xxx.txt 进行的修改、删除操作，将 xxx.txt 恢复到上次提交本地库时的状态，可执行git restore xxx ，这样再打开工作区的xxx.txt，
			会发现修改、删除的内容恢复了，仍然回到了没修改前的样子。该命令等同于git checkout xxx.txt

2、跟踪工作区的改动到缓存区
|     git add . 		                将当前目录下所有被改变或删除的文件夹及文件跟踪进暂存区	
|         或git add xxx  xxx    		将当前目录下工作区的xxx文件或文件夹xxx(及其下所有文件)跟踪进提交前的暂存区中，注意，add的是变化，比如删掉了一个文件，此
|				时仍需 add 该文件，表示的是将删除这个动作导致的变化情况予以跟踪；xxx可以是多个，中间用空格隔开即可
|    
|【注意】如果当前目录下工作区中有.gitignore文件，当工作区中的a.txt被包含在.gitignore中时，此时执行 git add a.txt会提示有错，不论.gitignore此时是否已经add进暂存区。并且
|执行git status 就会发现.gitignore和其他文件一样都呈现红色，表示等待被add进暂存区里，但是不会出现a.txt。
|
|2.1、逆add操作
|     git restore --staged xxx xxx		将当前目录下已跟踪进暂存区中的xxx文件或文件夹xxxx(及其下所有文件)移出暂存区，回归没有执行add进暂存区之前的工作区的状态
|
|2.2、【以下两个一定慎用】
|     git rm --cached xxx    		将当前目录下已经在暂存区中的xxx文件或文件夹xxx(及其下所有文件)删除，即不再让git跟踪该文件，但工作区的xxx文件或文件
|				夹x(及其下所有文件)仍保留。但这些都只针对当前版本而言，历史版本不受影响
|     git rm xxx			将当前目录下的工作区和暂存区中的xxx文件或文件夹x(及其下所有文件)删除。但这些只针对当前版本，历史版本不受影响。


3、复制缓存区的跟踪到本地库
|     git commit -m "balabala"		这样等同于复制暂存区内所有的跟踪内容到本地库并在vim里写上balabala
|             或git commit		或commit暂存区中的全部跟踪内容到本地库，命令执行后会进入vim并要求写入commit message，自定义写好保存退出即可；
|
|     git commit -m "balabala" xxx xxx	这样等同于commit xxx并在vim里写上balabala；xxx可以是多个，中间用空格隔开即可
|             或git commit xxx  xxx 		将暂存区的xxx文件或文件夹xxx（及其下所有文件）复制跟踪到当前目录下自定义创建的.git本地库，命令执行后会进入vim，自
|				定义写好保存退出即可；xxx可以为多个，中间用空格隔开即可
|
|3.1、修改当前所在版本的commit说明信息
|     git commit --amend		执行后就会进入vim，就可以看到当初commit时候自己写的说明内容，修改保存即可，然后git log --oneline就可以看到，本次
				对说明的修改又形成了一个新的版本，且被置于版本栈的最顶部！！同时让HEAD也一起自动到最顶部。

如果在上面的commit之后，又修改过工作区内的xxx文件
git status   执行后后会提示该xxx文件有新改动，需再次add 和 commit提交。



-----------------------------------------------------------------------------------本地库-----------------------------------------------------------------------------------------------
							 （版本栈）
		 【--oneline是短版本号无详情， --pretty=oneline是长版本号无详情，没有  --oneline、--pretty=oneline  则有详情】

git log --oneline --graph --decorate --color --all     不论当前处于哪个分支哪个版本，显示本地库中包含所有分支的全部版本的完整版本栈发展树(--graph)，和HEAD当前所在版本（和
					        当前所在分支相关，当前处于不同分支时，HEAD所在版本不同，工作区显示的版本内容即HEAD指向的版本），及比HEAD更
					        新的版本(--all)，以及一些尚未合并入主干的分支版本枝桠(--all)，也即所有的情况全部都显示，这种的最好看！！！
git log [--all]				 显示本地库中HEAD所在版本及更旧版本栈（不显示比HEAD更新版本，加上--all则显示），显示的这些版本都是完
					        整版本树中主干和最终并入主干的那些版本，而不显示未合入主干的分支版本枝桠。               （长版本号有详情显示）
git log --oneline [--all]			 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。  （短版本号无详情显示）
git log --pretty=oneline [--all]			 。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。  （长版本号无详情显示）

git reflog	    	    显示因在本地库git终端切换分支、移动到版本栈，而导致的HEAD@的移动轨迹；显示的移动轨迹为前新后旧顺序排列，序号
		    为0的HAED@{0}是当前HEAD所在版本
		    

【注意】如果最末尾显示冒号，表明还有未显示完的，键盘上的pgup为下移   pgdn为上移  空格为下翻  b为上翻   q或按住shift键双击z为退出显示记录


------------------------------------------------------------------------------本地库-------------------------------------------------------------------------------------------------------
					                （版本抵达&版本逆执行）
					    （表现为移动HEAD到本地库某历史版本）
0、版本逆执行
     git revert xxx		【执行前提是工作区 is clean的】对当前所在版本执行  版本xxx形成的逆步骤 ，并将结果作为一个最新的版本。例如，原始文件a提交后成为基础
			        版本是1，在这个版本的内容基础上加上文件b，提交到本地库形成版本2；在版本2的内容基础上再加一个文件c，提交到本地库形成版本3；此
			        时本地库的版本栈由下到上是 1、2、3  。当前处于版本3，执行git revert 1，则会形成版本4，版本4的内容呈现的结果是版本3基础上逆执行
			        版本1的形成步骤，即在将版本3的内容删去文件a形成版本4，注意，版本栈中版本3本身并未发生变化，它的版本内容依然有a、b、c三个文件。

1、抵达历史版本【该命令执行后，打开工作区的内容，显示的就是哈希标识符为xxx的版本的内容！！！！！】
     git reset --hard  xxx       移动HEAD到哈希标识符为xxx【可先git reflog显示一下】的历史版本
          或git reset --hard HEAD^^         将当前HEAD向后移动2个版本【一个^表示向后移动一步】
          或git reset --hard HEAD~3          将当前HEAD向后移动3个版本【~后面的3表示向后移动3步】

1.1、抵达版本&开叉
            移动到版本栈中某个历史版本后，在其基础上进行修改并提交形成一个版本，此时推送到远程库会失败，或此时执行git status会显示diverged，即分叉了，因此虽然远
            程库在此期间并未发生改动，但推送前仍需要先pull合并，该过程会将远程库的最新版本的内容作为本地的该次修改的基础（即合并）完善本次修改的最终呈现结果，最
            终作为一个最新版本推送到远程库。——也即移动到历史版本后修改并提交，是无法抛开已经存在的版本，而推到远程形成最新本版的；若想这么做，则需逆向逐步连续
            执行git revert 版本逆执行；或者抵达版本后，新建分支再修改并提交，进而推送到远程形成新分支。

2、git reset --hard HEAD        显示当前的本地库HEAD所在的版本【于此同时，该命令让该目录下的工作区、暂存区、本地库三者调整为一致，
				即工作区的内容状态全部保存为本地库最新版本，暂存区内未提交的也都提交了】		     

3、【下面的soft和mix不常用，也慎用】：
     git reset --hard  xxx  	（xxx为版本表示符）
	当 --hard是--soft	则是只移动本地库的HEAD指针，不移动工作区、暂存区的HEAD指针
	当 --hard是--mix	则是移动本地库的HEAD指针，且reset了暂存区
	当 --hard		则是工作区、暂存区同时重置且移动本地库的HEAD指针，三个区仍然一一对应




-------------------------------------------------------------------------------------分支---------------------------------------------------------------------------------------------

1、显示分支
     git branch -a 			查看当前目录下本地库所有分支 【红色是远程库有、本地未用的分支，白色是远程库有、本地进入过的分支，绿色是远程库有、当前所在分支】
     git branch -v 			查看当前目录下本地库中所有已进入过的（白色和绿色）分支和当前所在分支（绿色），及其详情。

2、切换到已有的xxx分支
     git checkout xxx				切换到本地库中名为xxx的分支，此时工作区中的内容也会变成该分支的，即打开Goland显示的就是该分支的内容。这个xxx必须和
					远程库已有分支名一致（可通过 git branch -a 查看，也可直接去工蜂上看），如果 xxx 在 git branch -a 显示时是红色的，经过 
					git checkout xxx 则会变为白色或绿色，即进入了本地使用状态。
     git checkout 远程库网址别名origin/xxx    	


3、新建分支xxx（并复制当前分支到新分支xxx，但仍停留在当前分支）
     git branch xxx     				新建分支xxx，同时默认复制获得当前所在分支的工作目录、暂存区、本地库的所有内容。底层其实不是复制，而是指针。
			——————————！！！注意最好不要和远程库的其他分支重名！！！
				
3.1、新建并进入分支xxx（复制当前分支内容到新建分支xxx并进入xxx分支）
     git checkout -b xxx			新建xxx分支并进入到该分支，新建时默认复制获得当前所在分支的内容到新分支xxx，连同历史版本记录都复制

3.2、新建一个空分支xxx   【慎用】
     git checkout --orphan <newBranchName>	创建newBranchName分支，但并不复制获得当前所在分支的所有内容，该分支的本地库是完全空的，只有工作区有内容，缓存
					也可能有内容——如果不执行add 和commit ，则本空分支不会真的存在，不会通过git branch -a 看到。


4、更新本地库分支xxx后再修改 
     git pull 远程库网址别名origin  远程库xxx分支         本地xxx分支一直没改动而远程库xxx分支有更新，则此时pull就是让本地库当前分支跟上远程库该分支的后来的变化。此时
					也让工作区的内容和远程库的最新版本一致，方便在最新版本的基础上修改。

4.1、合并远程库分支yyy到当前分支xxx
     git pull 远程库网址别名origin  远程库yyy分支	将远程库上的 yyy 分支合并到当前分支xxx，即让当前分支的修改，是基于远程库的不同于当前分支xxx的 yyy 分支之上的。  

     git pull https://github.com/j/zz.git   zzz分支         将另一个远程库上的zzz分支合并到本地库当前所在分支。（但另一个远程库和本地库也即origin必须有相关性，比如是fork的
					关系，否则报错fatal:refusing to merge unrelated histories）   
4.2、合并本地分支www到当前分支xxx
     git merge www				将当前目录下本地库中名为www的分支的内容中相对于当前所在分支有更新的部分，合并到当前所在分支xxx中。
			【注意】
			当master和slave两个分支都各自修改了同一文件a.txt并各自完成提交到本地库后，再在master分支上执行git merge slave 时，会提示自动合并有冲突。
			此时进入master分支内的该a.txt文件，会发现a.txt里两个分支的修改都写在里面了，但是用特殊符号标记和分隔开了。
			这时只需手动删除特殊符号【可手动增删a.txt中的内容】，然后保存退出，再对master执行add和commit到本地库即可
			【【特别注意：提交时 git commit -m "自定义备注"  后面不能再像一般的提交一样写上文件名a.txt】】，最后效果是master分支的本地库有了合并
			后的手动处理后的最新的a.txt的版本；而slave分支的本地库还是它自己修改a.txt后保存提交的版本。


5、推送分支 & 新建远程分支      【推送到远程库前记得先 pull ，但如果远程库没有xxx分支则无需pull】
     git push 远程库网址别名origin  xxx分支 				将本地库xxx分支推送到远程库上的同名分支xxx上，
		 ——————————！！！如果远程库上没有xxx分支，也即xxx分支是在本地新建的，则此举仍成功，表现为在远程库上新建这个分支，且含所有版本栈！！！
     【下面这个比较少用】
     git push 远程库网址别名origin  本地xxx分支：远程库test分支			将本地库 xxx 分支的内容推送到远程库上的test分支上，但不改变远程库的test分支名
							
5.1、覆盖推送分支【慎用】
     git push -f  远程库网址别名origin  本地库xxx分支:远程库test分支		将本地库 xxx 分支的内容覆盖推送到远程库上的test分支上，但不改变远程库的test分支名
								
     【下面的千万慎用】						如果此命令中的 本地库分支名master  处不填，则是删除远程库的test分支
     git push  -f 远程库网址别名origin  本地库xxx分支			 	将自己本地库内的xxx分支推送到别名为origin的经理远程库上的master主分支上。
				        
-f 为强行覆盖远程库的既有内容，注意这样会让远程库丢失历史版本，一切推平，把这次推送的作为首次推送！！！


6、更改当前所在分支名
     git branch -m newName			将当前所在分支的分支名改为newName【只能更改当前所在分支的名称！！！】

6.1、更改远程库分支名xxx为yyy
	0、git clone *****xxx		将远程库的分支xxx复制到本地来(连同它的历史版本信息)，如果因为本地之前就有向该xxx分支推送，即本地就有该分支的一模一样的内容，
				就不必该步骤
	1、git branch -b yyy     	从当前所在的与远程库xxx分支一模一样的本地分支中，复制切换到新分支yyy；这时yyy的内容与版本栈，和当前分支的是一模一样的
	2、git push 远程库网址别名origin --delete xxx         	把远程库分支xxx删掉
	3、git push 远程库网址别名origin yyy		不用pull直接向远程库推送这个远程库所没有的分支yyy
这样就实现了更改远程库某分支分支名的目的

7、删除本地库分支
     git branch -d xxx				删除本地库中名为xxx的分支【不能删除当前所在分支，只能删除当前所在分支之外的其他分支】

7.1、删除远程库分支
       git push 远程库网址别名origin --delete xxx  		将远程库中的xxx分支删除
           或 git push 远程库网址别名origin   :xxx	 	将远程库中的xxx分支删除  【即将本地库不存在的分支推到远程库的xxx分支上，则个不存在的分支就是冒号前的空格】



------------------------------------------------------------------------------推送到远程库&版本栈原理---------------------------------------------------------------------------------------
					【更多更详细可见  git使用方法总结--pull与merge解读.txt】
远程库是本地库版本栈的一模一样的呈现。
			
      1、推送本地库版本到远程库时，本地库的该版本必须是基于远程库最新版本的修改，如果不是基于Github远程库的最最最新版本所作的修改，是推送不上去的【报错 unable to access】，
因此，
      2、如果在我修改本地的内容期间，远程库发生了变化，则推送自己的版本到远程库前，必须先pull到本地【这个过程自动merge,将我的修改基于远程库之修改的基础之上】后，才可以
再推送上去作为远程库的最新版本；
      3、如果在我修改本地的内容期间，远程库没发生变化，即我要推送的版本就是基于远程库的最新版本而修改的版本，则无需pull，可以直接push，但不建议这样做，还是最好pull一下，
虽然会什么也不会发生。
      4、如果我本地一直没动而远程库后续又发生了变化，现在想让自己的本地库跟上远程库，那么直接先执行pull，这样fetch和merge的远程库版本就会按本该的顺序堆放到本地库版本栈
上，此时再打开本地的工作区，内容就会和远程库最新内容一样了。
     5、当然，在本地可以多次提交一些版本到本地库而不推送到远程库，最终推送到远程库时，这些版本栈都会在远程库有呈现。

     eg: 例如，远程库的最初版本是111，我拉取到本地后进行修改并提交到本地库，成为版本222；如果这个过程中，远程库被别人修改并变成了版本333，则此时我要上传自己的版本
222前，需要先pull远程库，这个pull包含了fetch和merge，即包含了将远程库版本333相较于版本111的变化跟进到我的版本222之前，再跟进我自己的修改成为版本222。因此，我的
本地库的版本栈情况是  最底下的是版本111，向上接着是版本333，最新版本是222。推送到远程库后远程库的版本情况也是如此。


（完）

------------------------------------------------------------------------------Github了解--------------------------------------------------------------------------------------
1、绿色Code按钮里的  https://github.com/clarence-secai/test.git 或 git@git.oa.com:clarence-secai/test.git 就是该项目远程库的网址链接。
2、经理在自己的github上某个仓库a的setting中添加collaborators，并将邀请链接【在pending invite按钮那里】发给员工，员工在浏览器输入邀请链接后，点击接受邀请，然后员工
     的Github主页上就有了经理的仓库a，这样员工就也可以在自己的电脑向远程库a来push自己的更新了。

//git fetch 远程仓库网址别名  远程仓库分支名			经理获取远程库到本地当前目录下的本地库内以一个【不可见的】新的分支而存在。
//						  【本地库新的这个分支名为   远程仓库网址别名/远程仓库分支名     
//							这个远程仓库分支名在Github这个仓库的主页上有按钮有显示】
//（(git checkout 远程仓库网址别名/xxx      		进入已下载到当前目录下的本地库的远程库xxx分支))
//git merge 远程仓库网址别名/远程仓库分支名		将已经fetch到当前目录下本地库的远程仓库分支，插入到它本该居于本地库的版本栈的位置中，并让我的本地的修改
//							是基于该分支版本的基础之上的，即大家理解的合并。
//						   【注意：合并有冲突时，按合并冲突解决办法解决】
//						   【再次注意：这样之后再add添加后commit提交到本地库时，不得再在命令后面跟上文件名】

下面pull等价于上述的fetch和merge两步一起的结果
【如果远程库在此期间没有新的改变，也可以省略pull直接push，但最好还是pull一下】：
【如果我的本地一直没改动而远程库有新变化，则此时pull就是让本地库当前分支跟上远程库的后来更迭的版本】：
git pull 远程库网址别名origin  远程库xxx分支      	将远程库拉取下来且合并到当前所在xxx分支，即将远程库(最新)版本插入到它本该居于本地库当前分支版本栈中的位置，并让我
					     的修改是基于它的基础之上的。
					【注意，当远程库在我修改本地的内容并提交到本地库期间也有更新时，则此时仍会把两个合并，而且如果有合并冲突，会有特
					     殊符号标记出各自更新的内容，需要再手动进行取舍。
					  【再次注意：这样之后再add添加后commit提交到本地库时，不得再在命令后面跟上文件名】



---------------------------===========
1、在考试函数内加一个额外管道，利用管道容量来控制考试函数的协程的并发数量
2、产生随机数的函数被多个协程使用，故产生随机数的函数内需加互斥锁
3、上述两者有异曲同工之妙：互斥锁相当于容量为1的控制产生随机数的函数的协程并发数量的管道！！！ :)
4、读写锁：对MySQL数据库的写入函数和读取函数同时开协程，故需使用读写锁，要么读取数据库的函数运行而写入数据库的函数等待，
要么写入数据的函数运行而读取数据库的函数等待首次写入数据库时，写入数据的函数开的协程与读取数据的函数的协程之间需加一个等
待时间，让写入数据库的协程先抢到读写锁先运行而读数据库的函数的协程等待，因为必须先写才有得读，但第一波考试过了而程序依然
在持续等待中运行时(既无写入也无读取)，如又有查询的则读取数据的函数的协程可以运行而写如数据的函数的协程继续等待，又有新一
批考试录入成绩地则写入数据库，如果读取数据的函数的协程还在运行，则写入数据的函数的协程得等着，直到读取数据的函数的协程结
束了，写入数据的函数的协程才能拿到读写锁而运行，这就是读写锁的功能——虽然数据库自带互斥锁，不怕读和写多个协程同时操作，
但无法做到读写锁才能做到：来读取者，数据库必已有其欲查之数据，即不会出现查不到是因为还未来得及写入的情况，如果查不到那一定
是因为数据库没有，而非没来得及写入数据库。

========================================================================================
https://zhuanlan.zhihu.com/p/30044692
知乎上对Git使用的全面介绍
========================================================================================
本文分析了git restore --stage <file>和git restore <file>两个命令，总结如下，

1、文件在暂存区且未对工作区的该文件作修改的情况
使用git restore --staged <file> 把文件从暂存区移动到工作区，即逆add操作；

2、文件在暂存区且对工作区的该文件已经修改的情况
使用 git restore --staged <file>     把文件从暂存区移动到工作区，即逆add操作，且不会撤销对工作区该文件修改的内容；
使用 git restore <file>       	    文件仍在暂存区，，，，，，，，，，，，，，且会撤销对工作区该文件修改的内容；

3、文件在工作区中被修改的情况
使用git add <file>     将文件又一次跟进到暂存区，且保留文件的修改；
使用git restore <file>  未将文件跟进到暂存区，且会撤销文件的修改；

总之：
对于git restore --staged <file>命令，把文件从暂存区撤回到工作区，保留文件最后一次修改的内容；
对于git restore <file>命令，会撤销文件的修改，而维持文件原本所在的工作区或跟进到的暂存区；


（完）